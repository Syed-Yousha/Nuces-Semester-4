# -*- coding: utf-8 -*-
"""k226007 Syed Yousha Mehdi - Copy of Session_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oVs7fc9VkvOZvMLbKOiCMX602d5KgN3T

**Lab Task 1**: Plot all the given functions to observe the roots by visualization, fill the table by your visual guess of root. We have plotted one function for you.</br>
1) $f(x)=cos(x)-1.3x$</br>
2) $f(x)=xcos(x)-2x^2+3x-1$</br>
3) $f(x)=2xcos(2x)-(x+1)^2$
"""

import numpy as np
from matplotlib import pyplot as plt

plt.rcParams["figure.figsize"] = [7.50, 7.50]

def f(x):
    return 2*x*(np.cos(2*x)) - (x+1)**2

x = np.linspace(-10,10 , 1000)
plt.plot(x,f(x), color='red')
plt.hlines(y=0,xmin=-10,xmax=10,color='blue')
plt.show()

"""**Lab Task 2**: Complete the missing code of bisection method accordding to the explained algorithm and find root of given problems by bisection method according to the instructions given in table.</br>
1) $f1(x)=cos(x)-1.3x$</br>
2) $f2(x)=xcos(x)-2x^2+3x-1$</br>
3) $f3(x)=2xcos(2x)-(x+1)^2$

"""

import numpy as np
from tabulate import tabulate

## module Bisection
''' root = bisection(func, x1, x2, tol=0.0001, max_iter=100):.
    Finds a root of f(x) = 0 by bisection.
    The root must be bracketed in (x1,x2).

'''

def func(x):
  return 2*x*(np.cos(2*x)) - (x+1)**2

def bisection(func, x1, x2, tol=0.0001, max_iter=100):
    if func(x1) * func(x2) >= 0:
        return  "Error: Choose different interval, function should have different signs at the interval endpoints."
    data=[]
    iter = 0
    xr = x2
    error = tol + 1

    while iter < max_iter and error > tol:
        xrold = xr
        xr = ((x1+x2)/2)
        iter += 1
        error = abs((xr - xrold) )

        test = func(x1) * func(xr)

        if test < 0:
          x2 = xr
        elif test > 0:
          x1 = xr
        else:
          error = 0
        # write your code here to replace value of x1 or x2 by xr

        data.append([iter+1,x1,func(x1),x2,func(x2),xr,func(xr),error])
    print(tabulate(data,headers=['#','x1','f(x1)','x2','f(x2)','xr','f(xr)',"error"],tablefmt="github"))
    print('\nRoot of given function is x=%.9f in n=%d number of iterations with a tolerence=%.4f' %(xr,iter,tol))

    return

bisection(func, -1, 2)

"""**Lab Task 3**: Find root of given problems by Newton Raphson method according to the instructions given in table.</br>
1) $f1(x)=cos(x)-1.3x$</br>
2) $f2(x)=xcos(x)-2x^2+3x-1$</br>
3) $f3(x)=2xcos(2x)-(x+1)^2$

"""

import numpy as np
from tabulate import tabulate

## module Newton_Raphson
''' newton_raphson(func, dfunc, x0, tol=1e-4, max_iter=1000)
    Finds a root of f(x) = 0 by newton_raphson.
'''
def func(x):
  return x*(np.cos(x)) - 2*x**2 + 3*x-1

def newton_raphson(func, dfunc, x0, tol=1e-4, max_iter=1000):
    xr = x0
    data=[]
    iter = 0
    error = tol + 1
    for i in range(max_iter):
        iter+=1
        fx = func(xr)
        dx = dfunc(xr)
        if abs(dx) < tol:
           raise Exception("Derivative is close to zero!")
        xrold=xr
        xr = xr - fx/dx
        error=abs(xr-xrold)
        data.append([iter,xr,func(xr),error])
        if error < tol:
           print(tabulate(data,headers=['Iteration','xr','f(xr)',"error"],tablefmt="github"))
           print('\nRoot of given function is x=%.9f in n=%d number of iterations with a tolerence=%.4f' %(xr,iter,tol))
           return

    raise Exception("Max iterations reached")

def dfunc(x):
  return -4*x*(np.sin(2*x)) + 2*(np.cos(2*x))-2*(x+1)
## initial guess
x0 = 0.7
newton_raphson(func, dfunc, x0)



"""**Lab Task 4**: Find root of given problems by using fsolve command of sympy.optimize</br>
1) $f1(x)=cos(x)-1.3x$</br>
2) $f2(x)=xcos(x)-2x^2+3x-1$</br>
3) $f3(x)=2xcos(2x)-(x+1)^2$

"""

from sympy import symbols, cos, Eq, fsolve

# Define the variable
x = symbols('x')

# Define the functions
f1 = cos(x) - 1.3 * x
f2 = x * cos(x) - 2 * x**2 + 3 * x - 1
f3 = 2 * x * cos(2 * x) - (x + 1)**2

# Solve for roots using fsolve
root_f1 = fsolve(f1, 0)  # Starting from x=0
root_f2 = fsolve(f2, 0)  # Starting from x=0
root_f3 = fsolve(f3, 0)  # Starting from x=0

# Display the roots
print("Root of f1(x):", root_f1)
print("Root of f2(x):", root_f2)
print("Root of f3(x):", root_f3)

"""**Lab Task 5**: Write program of Secant and False Position method by altering above codes."""

import numpy as np
from tabulate import tabulate

def func(x):
    return 2*x*(np.cos(2*x)) - (x+1)**2

def false_position(func, x1, x2, tol=0.0001, max_iter=100):
    if func(x1) * func(x2) >= 0:
        return "Error: Choose different interval, function should have different signs at the interval endpoints."

    data = []
    iter = 0
    xr = x2
    error = tol + 1

    while iter < max_iter and error > tol:
        xrold = xr
        xr = x2 - (func(x2) * (x1 - x2)) / (func(x1) - func(x2))
        iter += 1
        error = abs(xr - xrold)

        test = func(x1) * func(xr)

        if test < 0:
            x2 = xr
        elif test > 0:
            x1 = xr
        else:
            error = 0

        data.append([iter, x1, func(x1), x2, func(x2), xr, func(xr), error])

    print(tabulate(data, headers=['#', 'x1', 'f(x1)', 'x2', 'f(x2)', 'xr', 'f(xr)', "error"], tablefmt="github"))
    print('\nRoot of given function is x=%.9f in n=%d number of iterations with a tolerance=%.4f' % (xr, iter, tol))

    return

def secant_method(func, x0, x1, tol=1e-4, max_iter=1000):
    xr0 = x0
    xr1 = x1
    data = []
    iter = 0
    error = tol + 1

    for i in range(max_iter):
        iter += 1
        fx0 = func(xr0)
        fx1 = func(xr1)

        if fx1 - fx0 == 0:
            raise Exception("Division by zero in secant method!")

        xr = xr1 - fx1 * (xr1 - xr0) / (fx1 - fx0)
        error = abs(xr - xr1)

        data.append([iter, xr, func(xr), error])

        if error < tol:
            print(tabulate(data, headers=['Iteration', 'xr', 'f(xr)', "error"], tablefmt="github"))
            print('\nRoot of given function is x=%.9f in n=%d number of iterations with a tolerance=%.4f' % (xr, iter, tol))
            return

        xr0 = xr1
        xr1 = xr

    raise Exception("Max iterations reached in secant method")


print("\nFalse position method")
false_position(func, -1, 2)


# Second method
x0 = 0.7
x1 = 1.0

print("\n\nSecant method")
secant_method(func, x0, x1)